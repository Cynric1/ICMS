# -*- coding: utf-8 -*-
"""Supervised Learning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vScmqmw0PMtIcnJhRyIAvxdDZaJwXxzn
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta

ipi = pd.read_csv('/content/ipi.csv')
rpi = pd.read_csv('/content/rpi.csv')

def extract_time_series(ipi_df, rpi_df):
    # Convert date columns to datetime
    ipi_df['date'] = pd.to_datetime(ipi_df['date'])
    rpi_df['date'] = pd.to_datetime(rpi_df['date'])

    # Create year-month columns for matching
    ipi_df['year_month'] = ipi_df['date'].dt.strftime('%Y-%m')
    rpi_df['year_month'] = rpi_df['date'].dt.strftime('%Y-%m')

    result = []
    for _, rpi_row in rpi_df.iterrows():
        rpi_date = rpi_row['date']
        rpi_value = rpi_row['value']

        time_series = []
        complete_series = True

        for i in range(59, 0, -1):   # 59 months from ipi and 1 from rpi
            target_date = rpi_date - relativedelta(months=i)
            target_ym = target_date.strftime('%Y-%m')

            matching_ipi = ipi_df[ipi_df['year_month'] == target_ym]

            if not matching_ipi.empty:
                # Find closest maturity to 5 in case there is no 5
                idx = (matching_ipi['maturity'] - 5.0).abs().idxmin()
                ipi_value = matching_ipi.loc[idx, 'value']
                time_series.append(ipi_value)
            else:
                complete_series = False  # if data missed
                break

        if complete_series:
            time_series.append(rpi_value)
            result.append(time_series)

    return result

result = extract_time_series(ipi, rpi)

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
import matplotlib.pyplot as plt

result_array = np.array(result)

X = result_array[:, :59]  # First 59 elements are features
y = result_array[:, 59]   # Last element is the target

# (80% training, 20% testing)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardization for both
scaler_X = StandardScaler()
X_train_scaled = scaler_X.fit_transform(X_train)
X_test_scaled = scaler_X.transform(X_test)
scaler_y = StandardScaler()
y_train_scaled = scaler_y.fit_transform(y_train.reshape(-1, 1)).flatten()
y_test_scaled = scaler_y.transform(y_test.reshape(-1, 1)).flatten()

def build_model():
    model = Sequential([
        Dense(64, activation='relu', input_shape=(59,)),
        Dense(32, activation='relu'),
        Dense(1)
    ])

    model.compile(optimizer='adam', loss='mse', metrics=['mae'])
    return model

model = build_model()
early_stop = EarlyStopping(monitor='val_loss', patience=20, restore_best_weights=True)
history = model.fit(
    X_train_scaled, y_train_scaled,
    epochs=200,
    batch_size=16,
    validation_split=0.2,
    callbacks=[early_stop],
    verbose=1
)

loss, mae = model.evaluate(X_test_scaled, y_test_scaled, verbose=0)
print(f"Test MAE: {mae}") # The MAE here is based on scaled data

# Visualization
y_pred_scaled = model.predict(X_test_scaled).flatten()
y_test_orig = scaler_y.inverse_transform(y_test_scaled.reshape(-1, 1)).flatten()
y_pred_orig = scaler_y.inverse_transform(y_pred_scaled.reshape(-1, 1)).flatten()
plt.figure(figsize=(10, 8))
plt.scatter(y_test_orig, y_pred_orig, alpha=0.7)

min_val = min(min(y_test_orig), min(y_pred_orig))
max_val = max(max(y_test_orig), max(y_pred_orig))
plt.plot([min_val, max_val], [min_val, max_val], 'r--', lw=2)

plt.xlabel('Actual Values')
plt.ylabel('Predicted Values')
plt.title('Actual vs Predicted Values')
plt.grid(True)


# Here, we are testing on the original data
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
mae = mean_absolute_error(y_test_orig, y_pred_orig)
rmse = np.sqrt(mean_squared_error(y_test_orig, y_pred_orig))
r2 = r2_score(y_test_orig, y_pred_orig)

plt.figtext(0.15, 0.8, f'MAE: {mae:.4f}\nRMSE: {rmse:.4f}\nRÂ²: {r2:.4f}',
            bbox=dict(facecolor='white', alpha=0.8))
plt.tight_layout()
plt.show()

